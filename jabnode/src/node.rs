mod communication;

use crate::network::{Connection, Peer, PeerType};
use crate::KillToken;
use communication::Communication;
use jabcoin::core::{crypto::Sha256Hash, Address, Block, Blockchain, Transaction};
use jabcoin::network::{Header, Message};
use log::{error, info, warn};
use std::collections::{HashMap, VecDeque};
use std::net::Ipv4Addr;
use std::ops::DerefMut;
use std::sync::{Arc, Condvar, Mutex};

const PORT: u16 = 27182;

pub struct Config
{
    /// path to the block disk store
    pub blkpath: String,

    /// cache transactions inside the blockchain
    pub build_cache: bool,

    /// compute hashes to advance the blockchain
    pub mine: bool,
    pub count_chain_workers: usize,

    /// listen and process network communication
    pub listen_communication: bool,
    pub count_comm_workers: usize,

    /// vector of known peers
    pub peers: Vec<Peer>,

    pub peer: Peer,
}

impl Config
{
    pub fn new(
        blkpath: String,
        build_cache: bool,
        mine: bool,
        count_chain_workers: usize,
        listen_communication: bool,
        count_comm_workers: usize,
        peers: Vec<Peer>,
        peer: Peer,
    ) -> Config
    {
        Config {
            blkpath,
            build_cache,
            mine,
            listen_communication,
            count_comm_workers,
            count_chain_workers,
            peers,
            peer,
        }
    }

    pub fn with_default() -> Config
    {
        let slf = Peer::new(0, PeerType::FullNode, [127, 0, 0, 1].into());
        let p = Peer::new(1, PeerType::FullNode, [192, 168, 208, 115].into());
        let peers = vec![p];

        Config {
            blkpath: String::from("etc/blocks/"),
            build_cache: true,
            mine: true,
            listen_communication: true,
            count_comm_workers: 4,
            count_chain_workers: 1,
            peers,
            peer: slf,
        }
    }
}

struct State
{
    /// a cache of the state generated by  
    /// the blockchain
    economy: HashMap<Address, u64>,

    /// queue of freestanding transactions
    trx_queue: VecDeque<Transaction>,

    chain: Blockchain,
    peer: Peer,
    peers: Vec<Peer>,
}

pub struct Node
{
    communication: Arc<Communication>,
    state: Mutex<State>,
    cfg: Mutex<Config>,
    cvar: Condvar,
    killtoken: Arc<KillToken>,
}

impl Node
{
    pub fn new(cfg: Config, killtoken: Arc<KillToken>) -> Arc<Node>
    {
        let peers = cfg.peers.clone();
        let peer = cfg.peer.clone();

        let state = State {
            economy: HashMap::new(),
            trx_queue: VecDeque::new(),
            chain: Blockchain::new(),
            peers,
            peer,
        };

        Arc::new_cyclic(move |wk| Node {
            communication: Arc::new(Communication::new(wk.clone())),
            state: Mutex::new(state),
            cfg: Mutex::new(cfg),
            cvar: Condvar::new(),
            killtoken,
        })
    }

    fn handle_new_transaction(self: Arc<Self>, trx: Transaction)
    {
        info!("{:<30} {}", "received new transaction", trx.hash_str());

        if trx.check_validity()
        {
            let mut lg = self.state.lock().unwrap();
            let state = lg.deref_mut();
            let q = &mut state.trx_queue;

            self.cvar.notify_all();
            if let Some(_) = q.iter().find(|t| **t == trx)
            {
                info!("{:<30} {}", "already in queue.", trx.hash_str());
            }
            else
            {
                q.push_back(trx.clone());

                info!(
                    "{:<30} {} {}",
                    "queued at position ",
                    trx.hash_str(),
                    q.len()
                );

                info!("broadcasting transaction to connected full-nodes.");

                let msg = Message::with_data(
                    Header::BroadcastTransaction,
                    &serde_json::to_string(&trx).unwrap(),
                );

                for i in &state.peers
                {
                    if let Ok(mut conn) = Connection::new_try_peer_addr(i.address().clone(), PORT)
                    {
                        conn.write_msg(&msg).unwrap();
                    }
                    else
                    {
                        warn!("failed to connect to full-node {}.", i.address());
                    }
                }
            }
        }
        else
        {
            warn!("{:<30} {}", "invalid transaction!", trx.hash_str());
        }
    }

    fn handle_new_block(&self, blk: Block, peer: &Ipv4Addr)
    {
        info!("{peer}: {:<30} {}.", "received new block", blk.hash_str());
    }

    fn build_blockchain(&self)
    {
        info!("building blockchain from disk.");

        let mut blks = vec![];

        if let Ok(it) = std::fs::read_dir(&self.cfg.lock().unwrap().blkpath)
        {
            for i in it
            {
                let contents = std::fs::read_to_string(i.unwrap().path()).unwrap();

                if let Ok(blk) = serde_json::from_str::<Block>(&contents)
                {
                    info!("processing block {}.", blk.hash_str());
                    blks.push(blk);
                }
                else
                {
                    todo!();
                }
            }
        }
        else
        {
            todo!();
        }

        self.state.lock().unwrap().chain = Blockchain::try_from(blks).unwrap();
    }

    fn build_cache(&self)
    {
        let mut guard = self.state.lock().unwrap();
        let state = guard.deref_mut();

        let chain = &state.chain;
        let cache = &mut state.economy;

        for (_, blk) in chain.get_blocks()
        {
            *cache.entry(blk.get_miner().clone()).or_insert(0) += 10;

            for trx in blk.transactions()
            {
                let inp = trx.input();
                let out = trx.output();

                *cache.get_mut(inp.get_addr()).expect("wtf??") -= inp.get_value();
                let mut change = inp.get_value();

                for actor in out.transactors()
                {
                    change -= actor.get_value();
                    *cache.entry(actor.get_addr().clone()).or_insert(0) += actor.get_value();
                }

                *cache.get_mut(blk.get_miner()).unwrap() += change;
            }
        }
    }

    pub fn start(self: Arc<Self>)
    {
        self.build_blockchain();

        let peers = {
            let state = self.state.lock().unwrap();
            state.peers.clone()
        };

        if self.cfg.lock().unwrap().build_cache
        {
            self.build_cache();
        }

        for i in peers
        {
            if let Err(_) = self.communication.register_to_peer(i.address().clone())
            {
                error!("failed to connect to root node.");
            }
        }

        let com_arc = Arc::clone(&self.communication);
        let com_thread = std::thread::spawn(move || com_arc.start());

        while !self.killtoken.wait_on()
        {
            continue;
        }

        self.communication.request_stop();
        com_thread.join().unwrap();
    }
}

impl Drop for Node
{
    fn drop(&mut self)
    {
        println!("byebye");
    }
}
