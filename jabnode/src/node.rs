use crate::network::{Connection, Peer, PeerType};
use crate::threadpool::ThreadPool;

use jabcoin::core::{crypto::Sha256Hash, Address, Block, Blockchain, Transaction};
use jabcoin::network::{Header, Message};

use log::{error, info, warn};

use serde_json::error::Category;

use std::collections::{HashMap, VecDeque};
use std::net::TcpListener;
use std::sync::{Arc, Mutex};

pub struct Config
{
    /// path to the block disk store
    pub blkpath: String,

    /// cache transactions inside the blockchain
    pub build_cache: bool,

    /// compute hashes to advance the blockchain
    pub mine: bool,
    pub count_chain_workers: usize,

    /// listen and process network communication
    pub listen_communication: bool,
    pub count_comm_workers: usize,

    /// vector of known peers
    pub peers: Vec<Peer>,
}

impl Config
{
    pub fn new(
        blkpath: String,
        build_cache: bool,
        mine: bool,
        count_chain_workers: usize,
        listen_communication: bool,
        count_comm_workers: usize,
        peers: Vec<Peer>,
    ) -> Config
    {
        Config {
            blkpath,
            build_cache,
            mine,
            listen_communication,
            count_comm_workers,
            count_chain_workers,
            peers,
        }
    }

    pub fn with_default() -> Config
    {
        let p = Peer::new(1, PeerType::FullNode, [192, 168, 208, 115].into());
        let peers = vec![p];

        Config {
            blkpath: String::from("etc/blocks/"),
            build_cache: true,
            mine: true,
            listen_communication: true,
            count_comm_workers: 4,
            count_chain_workers: 1,
            peers,
        }
    }
}

struct State
{
    /// a cache of the state generated by  
    /// the blockchain
    economy: HashMap<Address, i64>,

    /// queue of freestanding transactions
    trx_queue: VecDeque<Transaction>,

    chain: Blockchain,
    peers: Vec<Peer>,
}

pub struct Node
{
    state: Mutex<State>,
    cfg: Mutex<Config>,
}

impl Node
{
    pub fn new(cfg: Config) -> Node
    {
        let peers = cfg.peers.clone();

        let state = State {
            economy: HashMap::new(),
            trx_queue: VecDeque::new(),
            chain: Blockchain::new(),
            peers,
        };

        Node {
            state: Mutex::new(state),
            cfg: Mutex::new(cfg),
        }
    }

    fn mine(self: Arc<Self>)
    {
        info!("starting to mine");
        info!("stopping to mine");
    }

    fn handle_new_transaction(self: Arc<Self>, trx: Transaction)
    {
        info!("{:<30} {}", "received new transaction", trx.hash_str());

        let q = &mut self.state.lock().unwrap().trx_queue;
        q.push_back(trx.clone());

        info!(
            "{:<30} {} {}",
            "queued at position ",
            trx.hash_str(),
            q.len()
        );
    }

    fn parse_msg(self: Arc<Self>, msg: Message)
    {
        match msg.header
        {
            Header::BroadcastTransaction =>
            {
                match serde_json::from_str::<Transaction>(&msg.body)
                {
                    Ok(t) =>
                    {
                        self.handle_new_transaction(t);
                    }
                    Err(e) =>
                    {
                        error!("{:<30} {e}", "failed to parse trx with error");
                    }
                };
            }
            Header::BroadcastBlock =>
            {
                match serde_json::from_str::<Block>(&msg.body)
                {
                    Ok(b) =>
                    {
                        info!("{:<30} {}", "received new block", b.hash_str());
                    }
                    Err(e) =>
                    {
                        error!("{:<30} {e}", "failed to parse block with error");
                    }
                };
            }
            _ => todo!(),
        }
    }

    fn handle_connection(self: Arc<Self>, mut conn: Connection)
    {
        info!("got a connection");

        loop
        {
            // check msg validity
            match conn.read_msg()
            {
                Ok(m) => Node::parse_msg(Arc::clone(&self), m),
                Err(e) => match e.classify()
                {
                    Category::Eof =>
                    {
                        warn!("reached EOF while reading msg");
                        break;
                    }
                    Category::Io =>
                    {
                        error!("failed to read msg with i/o error: {e}");
                    }
                    Category::Syntax | Category::Data =>
                    {
                        warn!("received invalid data with error: {e}");
                    }
                },
            }
        }
    }

    fn listen_communication(self: Arc<Self>)
    {
        let listener = TcpListener::bind("127.0.0.1:27182").unwrap();
        let pool = ThreadPool::new(self.cfg.lock().unwrap().count_comm_workers);

        for stream in listener.incoming()
        {
            let stream = stream.unwrap();

            let cpy = Arc::clone(&self);

            pool.execute(move || {
                cpy.handle_connection(Connection::new(stream));
            });
        }
    }

    fn build_blockchain(&mut self)
    {
        info!("building blockchain from disk");

        let mut blks = vec![];

        if let Ok(it) = std::fs::read_dir(&self.cfg.lock().unwrap().blkpath)
        {
            for i in it
            {
                let contents = std::fs::read_to_string(i.unwrap().path()).unwrap();

                if let Ok(blk) = serde_json::from_str::<Block>(&contents)
                {
                    info!("processing block {}", blk.hash_str());
                    blks.push(blk);
                }
                else
                {
                    todo!();
                }
            }
        }
        else
        {
            todo!();
        }

        self.state.lock().unwrap().chain = Blockchain::try_from(blks).unwrap();
    }

    fn build_cache(&mut self) {}

    pub fn start(mut self)
    {
        self.build_blockchain();

        if self.cfg.lock().unwrap().build_cache
        {
            self.build_cache();
        }

        let arc = Arc::new(self);

        let arccomm = Arc::clone(&arc);
        let commu = std::thread::spawn(move || Node::listen_communication(arccomm));

        let arcmine = Arc::clone(&arc);
        let mine = std::thread::spawn(move || Node::mine(arcmine));

        commu.join().unwrap();
        mine.join().unwrap();
    }
}
